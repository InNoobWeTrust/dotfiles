// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © InNoobWeTrust

//@version=5
strategy("Noob's MTF multi-EMA", max_bars_back = 3600, overlay=false, initial_capital = 100,default_qty_value = 100,default_qty_type = strategy.cash,margin_long = 5,margin_short = 5)
import TradingView/ta/8
import forbidden_gun/ma_lib/2

//=============================================================================
// MTF multi-emas
//=============================================================================

// Types
//-----------------------------------------------------------------------------{
type EmaTf
    string tf
    int len
    float ema
    float ema_filled
    color clr
//-----------------------------------------------------------------------------}

// Helper functions
//-----------------------------------------------------------------------------{
ema_tf(simple string tf, simple int len, src, simple bool smooth = false) =>
    request.security(syminfo.tickerid, tf, ta.ema(src, len), smooth ? barmerge.gaps_on : barmerge.gaps_off, smooth ? barmerge.lookahead_on : barmerge.lookahead_off)

ema_color(simple int tf_lvl, simple int max, simple color gradient_start, simple color gradient_end) =>
    color.from_gradient(tf_lvl,1,max,gradient_start,gradient_end)

newEma(string tf, simple int len, color clr, simple bool render, smooth = false) =>
    if render
        ema = ema_tf(tf,len, close, smooth)
        ema_filled = ta.valuewhen(not na(ema), ema, 0)
        EmaTf.new(tf, len, ema, ema_filled, clr)
    else
        EmaTf.new(na, na, na, na, color(na))

countdown(simple string tf) =>
    if timeframe.in_seconds(timeframe.period) < timeframe.in_seconds(tf)
        time_left = int(time_close(tf) - timenow)
    else
        na

fmt_countdown(simple string tf) =>
    cntdwn = countdown(tf)
    if not na(cntdwn)
        cntdwn := cntdwn / 1000
        hh = int(cntdwn / 3600)
        mm = int((cntdwn % 3600) / 60)
        ss = int(cntdwn % 60)
        str.format('ETA: {0,number,00}:{1,number,00}:{2,number,00}', hh,mm,ss)
    else
        'ETA: -- : -- : --'

trend_ico(trend) =>
    switch trend
        1 => '⬆︎' // Up
        -1 => '⬇︎' // Down
        0 => '〰︎' // Tangled
        => '?' // Unknown, data not available for calculation

trend_txt_color(trend) =>
    switch trend
        1 => #26a69a
        -1 => #ef5350
        0 => color.gray
        => color.silver

trend_bg_color(trend) =>
    switch trend
        1 => color.new(#26a69a,80)
        -1 => color.new(#ef5350,80)
        0 => color.new(color.gray,80)
        => color.new(color.silver,80)

mtf_bias_bgcolor(bias,max_bias,crossover_gradient_start,crossover_gradient_end,crossunder_gradient_end,crossunder_gradient_start) =>
    switch
        bias > 0 => color.from_gradient(bias,0,max_bias,crossover_gradient_start,crossover_gradient_end)
        bias < 0 => color.from_gradient(bias,-max_bias,0,crossunder_gradient_end,crossunder_gradient_start)
        => color(na)
//-----------------------------------------------------------------------------}

// Input
//-----------------------------------------------------------------------------{
ema1_grp = "► EMA fast"
ema1_inline = "EMA fast"
ema1_enable = input.bool(true, '', group = ema1_grp, inline = ema1_inline)
ema1_len = input.int(34, '', group = ema1_grp, inline = ema1_inline)
ema1_gradient_start = input.color(color.new(color.aqua,80), '', group = ema1_grp, inline = ema1_inline)
ema1_gradient_end = input.color(color.new(color.purple,50), '', group = ema1_grp, inline = ema1_inline)
ema1_max_tf = input.int(5, 'Max timeframes to show', minval=1,maxval=5, group = ema1_grp)
ema1_band_inline = 'HL bands'
ema1_band_enable = input.bool(true, ema1_band_inline, ema1_band_inline, group = ema1_grp, inline = ema1_band_inline)
ema1_band_gradient_start = input.color(color.new(color.aqua, transp = 80), '', group = ema1_grp, inline = ema1_band_inline)
ema1_band_gradient_end = input.color(color.new(color.purple, transp = 80), '', group = ema1_grp, inline = ema1_band_inline)

ema2_grp = "► EMA slow"
ema2_inline = "EMA slow"
ema2_enable = input.bool(true, '', group = ema2_grp, inline = ema2_inline)
ema2_len = input.int(89, '', group = ema2_grp, inline = ema2_inline)
ema2_gradient_start = input.color(color.new(color.yellow,80), '', group = ema2_grp, inline = ema2_inline)
ema2_gradient_end = input.color(color.new(color.maroon,50), '', group = ema2_grp, inline = ema2_inline)
ema2_max_tf = input.int(5, 'Max timeframes to show', minval=1,maxval=5, group = ema2_grp)

ema3_grp = "► EMA auxiliary"
ema3_inline = "EMA auxiliary"
ema3_enable = input.bool(false, '', group = ema3_grp, inline = ema3_inline)
ema3_len = input.int(610, '', group = ema3_grp, inline = ema3_inline)
ema3_gradient_start = input.color(color.new(color.white,80), '', group = ema3_grp, inline = ema3_inline)
ema3_gradient_end = input.color(color.new(color.gray,50), '', group = ema3_grp, inline = ema3_inline)
ema3_max_tf = input.int(5, 'Max timeframes to show', minval=1,maxval=5, group = ema3_grp)

tf_grp = "► Timeframes"
tf_inline = "Timeframes cfg"
tf1 = input.timeframe('1', '', group = tf_grp, inline = tf_inline)
tf2 = input.timeframe('5', '', group = tf_grp, inline = tf_inline)
tf3 = input.timeframe('30', '', group = tf_grp, inline = tf_inline)
tf4 = input.timeframe('240', '', group = tf_grp, inline = tf_inline)
tf5 = input.timeframe('D', '', group = tf_grp, inline = tf_inline)

smooth = input.bool(false, 'Smooth lines', tooltip = 'Enable this option will make ema lines in higher timeframes lag behind current bar')
variable_width = input.bool(false, 'Variable line width', tooltip = 'Increase line width for higher timeframes')

cross_grp = "► MTF crossing background (distribution/accumulation zones)"
cross_enable = input.bool(true, 'Enable',group = cross_grp)
crossunder_gradient_inline = 'Crossunder gradient color'
crossunder_gradient_start = input.color(color.new(color.orange,95), crossunder_gradient_inline, group = cross_grp, inline = crossunder_gradient_inline)
crossunder_gradient_end = input.color(color.new(color.maroon,20), '', group = cross_grp, inline = crossunder_gradient_inline)
crossover_gradient_inline = 'Crossover gradient color'
crossover_gradient_start = input.color(color.new(color.aqua,95), crossover_gradient_inline, group = cross_grp, inline = crossover_gradient_inline)
crossover_gradient_end = input.color(color.new(color.teal,20), '', group = cross_grp, inline = crossover_gradient_inline)
cross_tf_inline = 'Limit min/max timeframes'
cross_tf_min = input.int(1, cross_tf_inline, minval=1,maxval=4,group = cross_grp,inline = cross_tf_inline)
cross_tf_max = input.int(5, '', minval=2,maxval=5,group = cross_grp,inline = cross_tf_inline)

bias_cvd_grp = "► Bias CVD"
bias_cvd_window = input.int(9,'CVD sliding window',group = bias_cvd_grp)
bias_cvd_trend_detect_length = input.int(4,'CVD trend detection length',group = bias_cvd_grp)
bias_suppress_higher_tf = input.bool(true, 'Suppress higher timeframe',group = bias_cvd_grp)

strategy_grp = "► Strategy"
strategy_position_label = input.bool(true,"Show position label",group = strategy_grp)
strategy_position_bg = input.bool(true,"Show background on ideal long/short entry",group = strategy_grp)
strategy_sl_percent = input.float(0.05, "SL percentage", minval=0.005,maxval=0.995,group = strategy_grp)
strategy_long_enabled = input.bool(true, "Long action",group = strategy_grp)
strategy_short_enabled = input.bool(true, "Short action",group = strategy_grp)
//-----------------------------------------------------------------------------}

// Calculation
//-----------------------------------------------------------------------------{

// Timeframes
string[] tfs = array.from(tf1,tf2,tf3,tf4,tf5)
// EMA data
EmaTf[] ema1 = array.new<EmaTf>()
ema1.push(newEma(tf1, ema1_len, ema_color(1,ema1_max_tf,ema1_gradient_start,ema1_gradient_end), ema1_enable and 1 <= ema1_max_tf,smooth))
ema1.push(newEma(tf2, ema1_len, ema_color(2,ema1_max_tf,ema1_gradient_start,ema1_gradient_end), ema1_enable and 2 <= ema1_max_tf,smooth))
ema1.push(newEma(tf3, ema1_len, ema_color(3,ema1_max_tf,ema1_gradient_start,ema1_gradient_end), ema1_enable and 3 <= ema1_max_tf,smooth))
ema1.push(newEma(tf4, ema1_len, ema_color(4,ema1_max_tf,ema1_gradient_start,ema1_gradient_end), ema1_enable and 4 <= ema1_max_tf,smooth))
ema1.push(newEma(tf5, ema1_len, ema_color(5,ema1_max_tf,ema1_gradient_start,ema1_gradient_end), ema1_enable and 5 <= ema1_max_tf,smooth))

float[] ema1_h = array.new<float>()
ema1_h.push(ema1_enable and ema1_band_enable and 1 <= ema1_max_tf ? ema_tf(tf1, ema1_len, high, smooth) : na)
ema1_h.push(ema1_enable and ema1_band_enable and 2 <= ema1_max_tf ? ema_tf(tf2, ema1_len, high, smooth) : na)
ema1_h.push(ema1_enable and ema1_band_enable and 3 <= ema1_max_tf ? ema_tf(tf3, ema1_len, high, smooth) : na)
ema1_h.push(ema1_enable and ema1_band_enable and 4 <= ema1_max_tf ? ema_tf(tf4, ema1_len, high, smooth) : na)
ema1_h.push(ema1_enable and ema1_band_enable and 5 <= ema1_max_tf ? ema_tf(tf5, ema1_len, high, smooth) : na)

float[] ema1_l = array.new<float>()
ema1_l.push(ema1_enable and ema1_band_enable and 1 <= ema1_max_tf ? ema_tf(tf1, ema1_len, low, smooth) : na)
ema1_l.push(ema1_enable and ema1_band_enable and 2 <= ema1_max_tf ? ema_tf(tf2, ema1_len, low, smooth) : na)
ema1_l.push(ema1_enable and ema1_band_enable and 3 <= ema1_max_tf ? ema_tf(tf3, ema1_len, low, smooth) : na)
ema1_l.push(ema1_enable and ema1_band_enable and 4 <= ema1_max_tf ? ema_tf(tf4, ema1_len, low, smooth) : na)
ema1_l.push(ema1_enable and ema1_band_enable and 5 <= ema1_max_tf ? ema_tf(tf5, ema1_len, low, smooth) : na)

EmaTf[] ema2 = array.new<EmaTf>()
ema2.push(newEma(tf1, ema2_len, ema_color(1,ema2_max_tf,ema2_gradient_start,ema2_gradient_end), ema2_enable and 1 <= ema2_max_tf,smooth))
ema2.push(newEma(tf2, ema2_len, ema_color(2,ema2_max_tf,ema2_gradient_start,ema2_gradient_end), ema2_enable and 2 <= ema2_max_tf,smooth))
ema2.push(newEma(tf3, ema2_len, ema_color(3,ema2_max_tf,ema2_gradient_start,ema2_gradient_end), ema2_enable and 3 <= ema2_max_tf,smooth))
ema2.push(newEma(tf4, ema2_len, ema_color(4,ema2_max_tf,ema2_gradient_start,ema2_gradient_end), ema2_enable and 4 <= ema2_max_tf,smooth))
ema2.push(newEma(tf5, ema2_len, ema_color(5,ema2_max_tf,ema2_gradient_start,ema2_gradient_end), ema2_enable and 5 <= ema2_max_tf,smooth))

EmaTf[] ema3 = array.new<EmaTf>()
ema3.push(newEma(tf1, ema3_len, ema_color(1,ema3_max_tf,ema3_gradient_start,ema3_gradient_end), ema3_enable and 1 <= ema3_max_tf,smooth))
ema3.push(newEma(tf2, ema3_len, ema_color(2,ema3_max_tf,ema3_gradient_start,ema3_gradient_end), ema3_enable and 2 <= ema3_max_tf,smooth))
ema3.push(newEma(tf3, ema3_len, ema_color(3,ema3_max_tf,ema3_gradient_start,ema3_gradient_end), ema3_enable and 3 <= ema3_max_tf,smooth))
ema3.push(newEma(tf4, ema3_len, ema_color(4,ema3_max_tf,ema3_gradient_start,ema3_gradient_end), ema3_enable and 4 <= ema3_max_tf,smooth))
ema3.push(newEma(tf5, ema3_len, ema_color(5,ema3_max_tf,ema3_gradient_start,ema3_gradient_end), ema3_enable and 5 <= ema3_max_tf,smooth))

// Market structure data
float[] ema_trends = array.new<float>()
for idx = 0 to 4
    fast = ema1.get(idx).ema_filled
    slow = ema2.get(idx).ema_filled
    s = ma_lib.MaStructure.new(close, fast, slow)
    ema_trends.push(ma_lib.market_structure(s))

// MTF supertrend of EMA slow of lower timeframe crossing EMA fast of higher timeframe
float[] supertrend = array.new<float>()
min_tf_secs = timeframe.in_seconds(tfs.get(0))
float bias_val = 0.
float max_abs_bias = 0.

pstrct_at_cross(src1,src2) =>
    pstrct = ma_lib.pair_structure(src1,src2)
    cross = ta.cross(src1,src2)
    cross ? pstrct : 0

for idx = 0 to 4
    tf_secs = timeframe.in_seconds(tfs.get(idx))
    chart_tf_secs = timeframe.in_seconds('')
    if bias_suppress_higher_tf and tf_secs > chart_tf_secs
        supertrend.push(0)
    else if cross_tf_min > idx + 1 or cross_tf_max < idx + 2
        supertrend.push(0)
    else
        multiplier = tf_secs / min_tf_secs
        max_abs_bias += 8 * multiplier
        ema_fast = ema1.get(idx).ema_filled
        ema_slow = ema2.get(idx).ema_filled
        higher_ema_fast = ema1.get(idx + 1).ema_filled
        higher_ema_slow = ema2.get(idx + 1).ema_filled
        fast_cross = pstrct_at_cross(ema_fast,higher_ema_fast)
        mixed_cross = pstrct_at_cross(ema_fast,higher_ema_slow)
        slow_cross = pstrct_at_cross(ema_slow,higher_ema_slow)
        trend = fast_cross + 2 * mixed_cross + 4 * slow_cross
        supertrend.push(trend)

        bias_val += trend * multiplier

bias_cvd = math.sum(bias_val, bias_cvd_window)

position_entry = 0
// Long entry
bias_cvd_rising = ta.rising(bias_cvd,bias_cvd_trend_detect_length)
bias_cvd_falling = ta.falling(bias_cvd,bias_cvd_trend_detect_length)
if bias_cvd_rising
    position_entry := 1
// Short entry
else if bias_cvd_falling
    position_entry := -1

position = position_entry * 2 // 2 for long and -2 for short 

// Persistent variables to manage positions
var float entry_price = 0
var int entry_index = bar_index
var float sl_price  = 0
// Update entry price
entry_index := position * position[1] != 0 ? bar_index : entry_index
entry_price := position * position[1] != 0 ? close : entry_price
tick_size = syminfo.mintick * syminfo.pointvalue
sl_change = strategy_sl_percent * close
sl_ticks = sl_change / tick_size
sl_price := switch position
    2 => ta.highest(bar_index - entry_index + 1) - sl_change
    -2 => ta.lowest(bar_index - entry_index + 1) + sl_change
//-----------------------------------------------------------------------------}

// Plot
//-----------------------------------------------------------------------------{

// ema1
ema1_tf1_plt = plot(ema1.get(0).ema, '', ema1.get(0).clr, force_overlay = true, linewidth = variable_width ? 1 : 1)
ema1_tf2_plt = plot(ema1.get(1).ema, '', ema1.get(1).clr, force_overlay = true, linewidth = variable_width ? 2 : 1)
ema1_tf3_plt = plot(ema1.get(2).ema, '', ema1.get(2).clr, force_overlay = true, linewidth = variable_width ? 3 : 1)
ema1_tf4_plt = plot(ema1.get(3).ema, '', ema1.get(3).clr, force_overlay = true, linewidth = variable_width ? 4 : 1)
ema1_tf5_plt = plot(ema1.get(4).ema, '', ema1.get(4).clr, force_overlay = true, linewidth = variable_width ? 5 : 1)

ema1_tf1_h_plt = plot(ema1_h.get(0), '', ema_color(1,ema1_max_tf,ema1_band_gradient_start,ema1_band_gradient_end), force_overlay = true, linewidth = 1)
ema1_tf2_h_plt = plot(ema1_h.get(1), '', ema_color(2,ema1_max_tf,ema1_band_gradient_start,ema1_band_gradient_end), force_overlay = true, linewidth = 1)
ema1_tf3_h_plt = plot(ema1_h.get(2), '', ema_color(3,ema1_max_tf,ema1_band_gradient_start,ema1_band_gradient_end), force_overlay = true, linewidth = 1)
ema1_tf4_h_plt = plot(ema1_h.get(3), '', ema_color(4,ema1_max_tf,ema1_band_gradient_start,ema1_band_gradient_end), force_overlay = true, linewidth = 1)
ema1_tf5_h_plt = plot(ema1_h.get(4), '', ema_color(5,ema1_max_tf,ema1_band_gradient_start,ema1_band_gradient_end), force_overlay = true, linewidth = 1)

ema1_tf1_l_plt = plot(ema1_l.get(0), '', ema_color(1,ema1_max_tf,ema1_band_gradient_start,ema1_band_gradient_end), force_overlay = true, linewidth = 1)
ema1_tf2_l_plt = plot(ema1_l.get(1), '', ema_color(2,ema1_max_tf,ema1_band_gradient_start,ema1_band_gradient_end), force_overlay = true, linewidth = 1)
ema1_tf3_l_plt = plot(ema1_l.get(2), '', ema_color(3,ema1_max_tf,ema1_band_gradient_start,ema1_band_gradient_end), force_overlay = true, linewidth = 1)
ema1_tf4_l_plt = plot(ema1_l.get(3), '', ema_color(4,ema1_max_tf,ema1_band_gradient_start,ema1_band_gradient_end), force_overlay = true, linewidth = 1)
ema1_tf5_l_plt = plot(ema1_l.get(4), '', ema_color(5,ema1_max_tf,ema1_band_gradient_start,ema1_band_gradient_end), force_overlay = true, linewidth = 1)

fill(ema1_tf1_h_plt, ema1_tf1_l_plt, ema_color(1,ema1_max_tf,ema1_band_gradient_start,ema1_band_gradient_end), fillgaps = true)
fill(ema1_tf2_h_plt, ema1_tf2_l_plt, ema_color(2,ema1_max_tf,ema1_band_gradient_start,ema1_band_gradient_end), fillgaps = true)
fill(ema1_tf3_h_plt, ema1_tf3_l_plt, ema_color(3,ema1_max_tf,ema1_band_gradient_start,ema1_band_gradient_end), fillgaps = true)
fill(ema1_tf4_h_plt, ema1_tf4_l_plt, ema_color(4,ema1_max_tf,ema1_band_gradient_start,ema1_band_gradient_end), fillgaps = true)
fill(ema1_tf5_h_plt, ema1_tf5_l_plt, ema_color(5,ema1_max_tf,ema1_band_gradient_start,ema1_band_gradient_end), fillgaps = true)

// ema2
ema2_tf1_plt = plot(ema2.get(0).ema, '', ema2.get(0).clr, force_overlay = true, linewidth = variable_width ? 1 : 2)
ema2_tf2_plt = plot(ema2.get(1).ema, '', ema2.get(1).clr, force_overlay = true, linewidth = variable_width ? 2 : 2)
ema2_tf3_plt = plot(ema2.get(2).ema, '', ema2.get(2).clr, force_overlay = true, linewidth = variable_width ? 3 : 2)
ema2_tf4_plt = plot(ema2.get(3).ema, '', ema2.get(3).clr, force_overlay = true, linewidth = variable_width ? 4 : 2)
ema2_tf5_plt = plot(ema2.get(4).ema, '', ema2.get(4).clr, force_overlay = true, linewidth = variable_width ? 5 : 2)
// ema3
ema3_tf1_plt = plot(ema3.get(0).ema, '', ema3.get(0).clr, force_overlay = true, linewidth = variable_width ? 1 : 1)
ema3_tf2_plt = plot(ema3.get(1).ema, '', ema3.get(1).clr, force_overlay = true, linewidth = variable_width ? 2 : 1)
ema3_tf3_plt = plot(ema3.get(2).ema, '', ema3.get(2).clr, force_overlay = true, linewidth = variable_width ? 3 : 1)
ema3_tf4_plt = plot(ema3.get(3).ema, '', ema3.get(3).clr, force_overlay = true, linewidth = variable_width ? 4 : 1)
ema3_tf5_plt = plot(ema3.get(4).ema, '', ema3.get(4).clr, force_overlay = true, linewidth = variable_width ? 5 : 1)

// MTF bias bg and plot
bgcolor(mtf_bias_bgcolor(bias_val,max_abs_bias,crossover_gradient_start,crossover_gradient_end,crossunder_gradient_end,crossunder_gradient_start), force_overlay = true)
bias_color = switch
    bias_val > 0 => color.teal
    bias_val < 0 => color.maroon
    => color(na)
plot(bias_val, 'MTF bias', style = plot.style_columns, histbase = 0, color = bias_color)
bias_cvd_color = switch
    bias_cvd > 0 => color.aqua
    bias_cvd < 0 => color.orange
    => color(na)
cvd_plt = plot(bias_cvd, 'MTF bias CVD', color = bias_cvd_color)

// Ideal entry for long/short
position_color = switch
    strategy_position_bg and position_entry > 0 => strategy_position_bg ? color.new(color.green,90) : color(na)
    strategy_position_bg and position_entry < 0 => strategy_position_bg ? color.new(color.red,90) : color(na)
    => color(na)
bgcolor(position_color)

// Trend summary and countdown to bar close
cntdwn_tb = table.new(position.top_right, 3, 5, force_overlay = true)
countdowns = array.from(fmt_countdown(tf1),fmt_countdown(tf2),fmt_countdown(tf3),fmt_countdown(tf4),fmt_countdown(tf5))

for idx = 0 to 4
    trend = ema_trends.get(idx)
    ico = trend_ico(trend)
    txt_color = trend_txt_color(trend)
    bg_color = trend_bg_color(trend)
    table.cell(cntdwn_tb,0,idx,tfs.get(idx),text_color = color.gray,bgcolor = na)
    table.cell(cntdwn_tb,1,idx,ico,text_color = txt_color,bgcolor = bg_color)
    table.cell(cntdwn_tb,2,idx,countdowns.get(idx),text_color = color.gray,bgcolor = na)
//-----------------------------------------------------------------------------}

// Strategic actions
//-----------------------------------------------------------------------------{
close_long() =>
    if strategy_long_enabled and strategy.opentrades.size(strategy.opentrades - 1) > 0
        label.new(bar_index - 1,high + close*0.01,text='C',xloc=xloc.bar_index,style = label.style_text_outline,size = size.tiny,color=color.gray,force_overlay = true)
        strategy.close('Long')
close_short() =>
    if strategy_short_enabled and strategy.opentrades.size(strategy.opentrades - 1) < 0
        label.new(bar_index - 1,low - close*0.01,text='C',xloc=xloc.bar_index,style = label.style_text_outline,size = size.tiny,color=color.gray,force_overlay = true)
        strategy.close('Short')
order_long() =>
    close_short()
    if strategy_long_enabled
        if strategy.opentrades.size(strategy.opentrades - 1) <= 0
            label.new(bar_index - 1,low - close*0.01,text='L',xloc=xloc.bar_index,style = label.style_text_outline,size = size.tiny,color=color.green,force_overlay = true)
        strategy.entry('Long',strategy.long)
order_short() =>
    close_long()
    if strategy_short_enabled
        if strategy.opentrades.size(strategy.opentrades - 1) >= 0
            label.new(bar_index - 1,high + close*0.01,text='S',xloc=xloc.bar_index,style = label.style_text_outline,size = size.tiny,color=color.red,force_overlay = true)
        strategy.entry('Short',strategy.short)
switch position
    2 => order_long(),strategy.exit('SL Long','Long',stop = sl_price)
    -2 => order_short(),strategy.exit('SL Short', 'Short',stop = sl_price)
    1 => close_long()
    -1 => close_short()
// Trailing stop (sl_price is updated every bar to reduce risk)
if strategy.opentrades.size(strategy.opentrades - 1) > 0
    strategy.exit('SL Long','Long',stop = sl_price)
else if strategy.opentrades.size(strategy.opentrades - 1) < 0
    strategy.exit('SL Short', 'Short',stop = sl_price)
//-----------------------------------------------------------------------------}